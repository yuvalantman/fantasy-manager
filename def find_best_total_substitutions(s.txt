def find_best_total_substitutions(self, extra_salary=0):
        """Finds the best 1 or 2 substitutions that improve total form while respecting salary cap and position balance."""
        
        print("\nğŸ” DEBUG: Starting Best Total Substitutions...\n")  # âœ… Debug Start

        # Compute current total form and salary
        current_form = self.my_team["Form"].sum()
        current_salary = self.my_team["$"].sum()
        max_salary = current_salary + extra_salary

        print(f"ğŸ”µ Current Team Form: {current_form}, Salary: {current_salary}, Max Salary: {max_salary}\n")  # âœ… Debug Current Team

        self.my_team = self.my_team.rename(columns={"$": "Salary"})
        self.best_filter = self.best_filter.rename(columns={"$": "Salary"})
        self.my_team["Salary"] = self.my_team["Salary"].astype(float)
        self.best_filter["Salary"] = self.best_filter["Salary"].astype(float)
        # Only consider top 50 players by form instead of all
        available_players = self.best_filter[~self.best_filter["Player"].isin(self.my_team["Player"])].copy()
        available_players = available_players.sort_values(by="Form", ascending=False)

        print(f"ğŸ“Œ Available Players Before Filtering: {len(available_players)}\n")  # âœ… Debug Number of Available Players

        best_team = self.my_team.copy()
        best_form = current_form
        best_salary = current_salary
        best_out, best_in = [], []

        # Try 1-player and 2-player swaps
        for num_swaps in [1, 2]:
            for out_players in itertools.combinations(self.my_team.itertuples(index=False, name="PlayerTuple"), num_swaps):
                out_list = list(out_players)

                # Compute available salary (sum of removed players)
                available_salary = sum(float(player.Salary) for player in out_list) + extra_salary

                # Get positions needed after removing these players
                needed_pos = [player.Pos for player in out_list]

                print(f"ğŸ”„ Checking Out Players: {[p.Player for p in out_list]}, Available Salary: {available_salary}, Needed Positions: {needed_pos}")  # âœ… Debug Out Players

                # **Filter replacements by position and salary**
                valid_replacements = available_players[
                    (available_players["Pos"].isin(needed_pos)) & 
                    (available_players["Salary"] <= available_salary)
                ].sort_values(by="Form", ascending=False).head(50)  # Further limit to top 50

                print(f"âœ… Valid Replacements Found: {len(valid_replacements)} for Positions: {needed_pos}\n")  # âœ… Debug Number of Valid Replacements

                if len(valid_replacements) < num_swaps:
                    print("âŒ Skipping - Not enough valid replacements!\n")  # âœ… Debug Skipping Due to No Replacements
                    continue  

                # Try all possible replacement combinations
                for in_players in itertools.combinations(valid_replacements.itertuples(index=False, name="PlayerTuple"), num_swaps):
                    in_list = list(in_players)

                    # **Ensure 5 front / 5 back balance**
                    new_team = self.my_team[~self.my_team["Player"].isin([p.Player for p in out_list])].copy()
                    new_team = pd.concat([new_team, pd.DataFrame(in_list, columns=self.my_team.columns)], ignore_index=True)
                    
                    new_team["Salary"] = new_team["Salary"].astype(float)
                    new_form = new_team["Form"].sum()
                    new_salary = new_team["Salary"].sum()

                    # **Check salary constraint before continuing**
                    if new_salary > max_salary:
                        print(f"ğŸ’° Skipping - New Team Salary {new_salary} Exceeds Max {max_salary}!\n")  # âœ… Debug Salary Exceeded
                        continue  

                    # Ensure positional balance remains valid
                    front_count = new_team["Pos"].value_counts().get("front", 0)
                    back_count = new_team["Pos"].value_counts().get("back", 0)

                    if front_count != 5 or back_count != 5:
                        print(f"âŒ Skipping - Invalid Position Balance! Front: {front_count}, Back: {back_count}\n")  # âœ… Debug Invalid Position Balance
                        continue  

                    # **Update best team if better**
                    if new_form > best_form:
                        print(f"âœ… Found Better Team! New Form: {new_form}, Old Form: {best_form}\n")  # âœ… Debug Found Better Team
                        best_team = new_team.copy()
                        best_form = new_form
                        best_salary = new_salary
                        best_out = [p.Player for p in out_list]
                        best_in = [p.Player for p in in_list]

        # **Final Debug Summary**
        print(f"ğŸ”µ Current Team - Form: {current_form}, Salary: {current_salary}")
        print(f"ğŸŸ¢ New Team - Form: {best_form}, Salary: {best_salary}")

        if best_out and best_in:
            print(f"ğŸ”„ Substitutions Made:")
            print(f"âŒ Out: {', '.join(best_out)}")
            print(f"âœ… In: {', '.join(best_in)}")
        else:
            print("âœ… No substitutions made (no possible improvement within salary cap).")

        return best_team, best_form.round(2), best_salary.round(1), best_out, best_in